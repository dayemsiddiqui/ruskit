use sqlx::{Pool, Sqlite, Row};
use std::fs;
use std::path::Path;
use inflector::Inflector;
use crate::framework::database::DatabaseError;

pub struct Column {
    pub name: String,
    pub type_name: String,
    pub nullable: bool,
    pub is_primary_key: bool,
}

pub async fn inspect_table(pool: &Pool<Sqlite>, table_name: &str) -> Result<Vec<Column>, DatabaseError> {
    let rows = sqlx::query(
        "SELECT name, type, `notnull`, pk 
         FROM pragma_table_info(?)"
    )
    .bind(table_name)
    .fetch_all(pool)
    .await?;

    let mut columns = Vec::new();
    for row in rows {
        let name: String = row.get("name");
        let type_name: String = row.get("type");
        let not_null: i32 = row.get("notnull");
        let is_primary_key: i32 = row.get("pk");

        columns.push(Column {
            name,
            type_name,
            nullable: not_null == 0 && is_primary_key == 0, // Primary keys are never nullable
            is_primary_key: is_primary_key > 0,
        });
    }

    Ok(columns)
}

pub async fn generate_entity(pool: &Pool<Sqlite>, table_name: &str) -> Result<String, DatabaseError> {
    let columns = inspect_table(pool, table_name).await?;
    let struct_name = table_name.to_singular().to_pascal_case();
    
    let mut entity_content = format!(
r#"//! This file is auto-generated after running database migrations.
//! DO NOT EDIT THIS FILE MANUALLY.
//! 
//! To regenerate this file, run:
//! ```bash
//! cargo kit migrate
//! ```
//! 
//! To modify the schema, create a new migration:
//! ```bash
//! cargo kit make:migration add_field_to_{} --model {}
//! ```
//! 
//! Then edit the migration file and run:
//! ```bash
//! cargo kit migrate
//! ```

use crate::framework::prelude::*;

/// Represents a record in the `{}` table.
/// This struct is automatically generated from the database schema.
#[derive(Debug, Serialize, Deserialize, FromRow, GenerateValidationFields)]
pub struct {struct_name} {{
"#, table_name, struct_name, table_name);

    for column in columns {
        let rust_type = match column.type_name.to_uppercase().as_str() {
            "INTEGER" => "i64",
            "REAL" => "f64",
            "TEXT" => "String",
            "BOOLEAN" => "bool",
            "DATETIME" => "String",
            _ => "String", // Default to String for unknown types
        };

        let field_type = if column.nullable && !column.is_primary_key {
            format!("Option<{}>", rust_type)
        } else {
            rust_type.to_string()
        };

        // Add field documentation
        if column.is_primary_key {
            entity_content.push_str("    /// Primary key of the record\n");
        }
        if column.nullable {
            entity_content.push_str("    /// This field is nullable\n");
        }
        
        if column.name == "id" {
            entity_content.push_str("    #[sqlx(default)]\n");
        }
        
        entity_content.push_str(&format!("    pub {}: {},\n", column.name, field_type));
    }

    entity_content.push_str("}\n");
    Ok(entity_content)
}

pub async fn generate_all_entities(pool: &Pool<Sqlite>) -> Result<(), DatabaseError> {
    let tables = sqlx::query(
        "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name != 'migrations'"
    )
    .fetch_all(pool)
    .await?;

    let entities_dir = Path::new("src/app/entities");
    if !entities_dir.exists() {
        fs::create_dir_all(entities_dir)?;
    }

    let mut mod_content = String::new();

    for row in tables {
        let table_name: String = row.get("name");
        let entity_content = generate_entity(pool, &table_name).await?;
        let file_name = table_name.to_singular();
        let struct_name = file_name.to_pascal_case();
        
        // Write entity file
        let entity_file = entities_dir.join(format!("{}.rs", file_name));
        fs::write(&entity_file, entity_content)?;
        println!("Generated entity file: {}", entity_file.display());

        // Add to mod.rs
        mod_content.push_str(&format!("mod {};\n", file_name));
        mod_content.push_str(&format!("pub use {}::{};\n", file_name, struct_name));
    }

    // Write mod.rs
    let mod_file = entities_dir.join("mod.rs");
    fs::write(mod_file, mod_content)?;

    Ok(())
} 