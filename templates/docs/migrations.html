{% extends "docs_base.html" %}

{% block content %}
<div class="prose prose-slate max-w-none">
    <h1>Database Migrations</h1>
    
    <p>Migrations are version control for your database schema. They allow you to modify your database structure in a consistent and repeatable way.</p>

    <h2>Creating Migrations</h2>
    <p>Generate a new migration using the CLI:</p>

    <pre><code class="language-bash">cargo kit make:migration create_users_table</code></pre>

    <p>This creates a new migration in <code>src/database/migrations/YYYYMMDDHHMMSS_create_users_table.rs</code>:</p>

    <pre><code class="language-rust">use sea_orm_migration::prelude::*;

#[derive(DeriveMigration)]
pub struct Migration;

#[async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(Users::Table)
                    .col(ColumnDef::new(Users::Id).integer().not_null().auto_increment().primary_key())
                    .col(ColumnDef::new(Users::Name).string().not_null())
                    .col(ColumnDef::new(Users::Email).string().not_null().unique_key())
                    .col(ColumnDef::new(Users::Password).string().not_null())
                    .col(ColumnDef::new(Users::CreatedAt).timestamp().not_null())
                    .col(ColumnDef::new(Users::UpdatedAt).timestamp().not_null())
                    .to_owned(),
            )
            .await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(Users::Table).to_owned())
            .await
    }
}

#[derive(DeriveIden)]
enum Users {
    Table,
    Id,
    Name,
    Email,
    Password,
    CreatedAt,
    UpdatedAt,
}</code></pre>

    <h2>Running Migrations</h2>
    <p>Run your migrations using the CLI:</p>

    <pre><code class="language-bash"># Run all pending migrations
cargo kit migrate

# Rollback the last migration
cargo kit migrate:rollback

# Rollback all migrations
cargo kit migrate:reset

# Refresh the database (rollback all and migrate)
cargo kit migrate:refresh</code></pre>

    <h2>Column Types</h2>
    <p>SeaORM supports various column types:</p>

    <pre><code class="language-rust">// Numeric types
.col(ColumnDef::new(Column::Id).integer().not_null())
.col(ColumnDef::new(Column::Price).decimal().not_null())
.col(ColumnDef::new(Column::Count).big_integer())
.col(ColumnDef::new(Column::Score).float())

// String types
.col(ColumnDef::new(Column::Name).string().not_null())
.col(ColumnDef::new(Column::Description).text())
.col(ColumnDef::new(Column::Code).char_len(5))

// Boolean
.col(ColumnDef::new(Column::IsActive).boolean().not_null())

// Date and Time
.col(ColumnDef::new(Column::CreatedAt).timestamp().not_null())
.col(ColumnDef::new(Column::Date).date())
.col(ColumnDef::new(Column::Time).time())</code></pre>

    <h2>Modifying Tables</h2>
    <p>Common table modifications:</p>

    <pre><code class="language-rust">// Add column
manager
    .alter_table(
        Table::alter()
            .table(Posts::Table)
            .add_column(ColumnDef::new(Posts::Views).integer().default(0))
            .to_owned(),
    )
    .await?;

// Drop column
manager
    .alter_table(
        Table::alter()
            .table(Posts::Table)
            .drop_column(Posts::Views)
            .to_owned(),
    )
    .await?;

// Rename column
manager
    .alter_table(
        Table::alter()
            .table(Posts::Table)
            .rename_column(Posts::Title, Posts::Heading)
            .to_owned(),
    )
    .await?;

// Add index
manager
    .create_index(
        Index::create()
            .table(Posts::Table)
            .col(Posts::Title)
            .to_owned(),
    )
    .await?;</code></pre>

    <h2>Foreign Keys</h2>
    <p>Create relationships between tables:</p>

    <pre><code class="language-rust">// Create posts table with foreign key
manager
    .create_table(
        Table::create()
            .table(Posts::Table)
            .col(ColumnDef::new(Posts::Id).integer().not_null().auto_increment().primary_key())
            .col(ColumnDef::new(Posts::UserId).integer().not_null())
            .col(ColumnDef::new(Posts::Title).string().not_null())
            .col(ColumnDef::new(Posts::Content).text())
            .foreign_key(
                ForeignKey::create()
                    .name("fk-posts-user_id")
                    .from(Posts::Table, Posts::UserId)
                    .to(Users::Table, Users::Id)
                    .on_delete(ForeignKeyAction::Cascade)
                    .on_update(ForeignKeyAction::Cascade),
            )
            .to_owned(),
    )
    .await?;</code></pre>

    <h2>Best Practices</h2>
    <ul>
        <li>Always provide both up and down migrations</li>
        <li>Keep migrations small and focused</li>
        <li>Use meaningful names for migrations</li>
        <li>Test migrations before applying to production</li>
        <li>Back up your database before running migrations in production</li>
        <li>Use foreign key constraints to maintain data integrity</li>
        <li>Consider indexing for frequently queried columns</li>
    </ul>

    <h2>Testing Migrations</h2>
    <p>Test your migrations in a separate database:</p>

    <pre><code class="language-rust">#[tokio::test]
async fn test_migrations() {
    // Setup test database
    let db = setup_test_db().await;

    // Run migrations
    Migrator::up(&db, None).await.unwrap();

    // Verify table exists
    let table_exists = db
        .execute("SELECT * FROM information_schema.tables WHERE table_name = 'users'")
        .await
        .unwrap()
        .rows_affected() > 0;

    assert!(table_exists);

    // Test rollback
    Migrator::down(&db, None).await.unwrap();
}</code></pre>
</div>
{% endblock %} 